<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>NOS-T</title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.85/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
      integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2"
      crossorigin="anonymous"
    />
    <script type="text/javascript" src="env.js"></script>
  </head>

  <body>
    <main role="main" class="container-fluid">
      <div id="cesiumContainer"></div>
    </main>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.85/Build/Cesium/Cesium.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"
      type="text/javascript"
    ></script>
    <script
      src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
      integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx"
      crossorigin="anonymous"
    ></script>
    <script>
      var CESIUM_ACCESS_TOKEN = TOKEN;
      var BROKER_HOST = HOST;
      var BROKER_PORT = PORT;
      var BROKER_CLIENT_USERNAME = USERNAME;
      var BROKER_CLIENT_PASSWORD = PASSWORD;

      $(document).ready(function () {
        Cesium.Ion.defaultAccessToken = CESIUM_ACCESS_TOKEN;
        var clock = new Cesium.Clock({
          currentTime: Cesium.JulianDate.fromIso8601("2014-01-23T05:11:59Z"),
          clockStep: Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER,
          multiplier: 0, // how much time to advance each SYSTEM CLOCK tick
          shouldAnimate: false,
        });
        const viewer = new Cesium.Viewer("cesiumContainer", {
          terrainProvider: Cesium.createWorldTerrain(),
          baseLayerPicker: false,
          homeButton: false,
          infoBox: false,
          geocoder: false,
          selectionIndicator: false,
          navigationHelpButton: false,
          navigationInstructionsInitiallyVisible: false,
          timeline: true,
          imageryProvider: new Cesium.IonImageryProvider({ assetId: 3845 }),
          clockViewModel: new Cesium.ClockViewModel(clock),
        });
        const position = new Cesium.Cartesian3(-2.9205e6, 711755, -6.41302e6);
        const orientation = new Cesium.Quaternion(
          0.974126,
          0.0617359,
          -0.207549,
          -0.0647352
        );
        const blueBox = viewer.entities.add({
          name: "Blue box",
          position: position,
          orientation: orientation,
          point: {
            pixelSize: 10,
            color: Cesium.Color.BLUE,
            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
              1250000.5
            ),
          },
          box: {
            dimensions: new Cesium.Cartesian3(360000.0, 230000.0, 115000.0),
            material: Cesium.Color.SNOW,
            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
              0.0,
              12500000000.5
            ),
            outline: true,
            outlineWidth: 5.0,
          },
          cylinder: {
            length: 190000.0,
            topRadius: 20000.0,
            bottomRadius: 0.0,
            material: Cesium.Color.GOLD,
          },
        });

        var point = viewer.entities.add({
          position: new Cesium.Cartesian3.fromDegrees(-8, -35),
          point: {
            pixelSize: 15,
            color: Cesium.Color.CYAN,
            outline: true,
            outlineWidth: 1.0,
          },
        });

        var point = viewer.entities.add({
          position: new Cesium.Cartesian3.fromDegrees(9, -2),
          point: {
            pixelSize: 15,
            color: Cesium.Color.CYAN,
            outline: true,
            outlineWidth: 1.0,
          },
        });

        var point = viewer.entities.add({
          position: new Cesium.Cartesian3.fromDegrees(-16, 13),
          point: {
            pixelSize: 15,
            color: Cesium.Color.CYAN,
            outline: true,
            outlineWidth: 1.0,
          },
        });

        var point = viewer.entities.add({
          position: new Cesium.Cartesian3.fromDegrees(-6, 37),
          point: {
            pixelSize: 15,
            color: Cesium.Color.CYAN,
            outline: true,
            outlineWidth: 1.0,
          },
        });

        var point = viewer.entities.add({
          position: new Cesium.Cartesian3.fromDegrees(-24, 65),
          point: {
            pixelSize: 15,
            color: Cesium.Color.CYAN,
            outline: true,
            outlineWidth: 1.0,
          },
        });

        <!-- viewer.scene.globe.enableLighting = true; -->
        viewer.trackedEntity = blueBox;

        // create a MQTT client
        var client = new Paho.MQTT.Client(BROKER_HOST, BROKER_PORT, "");
        var satellites = {}; <!-- Positions of satellites as points at altitude, BLUE out of comms range, GREEN in comms range -->
        var sensorCircles = {}; <!-- Circles showing views of nadir pointed satellites -->
        var commsCones = {}; <!-- Views from ground station FOR comms -->
        var commsRange = false; <!-- Initialize this commsRange boolean as false, but will update based on satellite subscription -->
        var satColor = Cesium.Color.BLUE; <!-- Initialize satColor as Cesium's default BLUE, which is color when commsRange is false -->
        var fires = viewer.scene.primitives.add(
          new Cesium.PointPrimitiveCollection()
        ); <!-- Initialize fires as primitive points since there will be so many -->
        var grounds = {}; <!-- Surface position of ground stations as PINK points -->
        var updates = {};

        function handleMessage(message) {
          // get the message payload as a string
          <!-- console.log(message.payloadString); -->
          var payload = message.payloadString;
          var topic = message.destinationName;
          // try to parse and stringify a JSON string
          try {
            if (topic == "BCtest/manager/init") {
              payload = JSON.parse(message.payloadString);
              viewer.clockViewModel.currentTime = Cesium.JulianDate.fromIso8601(
                payload.taskingParameters.simStartTime
              );
              viewer.clockViewModel.startTime = Cesium.JulianDate.fromIso8601(
                payload.taskingParameters.simStartTime
              );
              viewer.clockViewModel.stopTime = Cesium.JulianDate.fromIso8601(
                payload.taskingParameters.simStopTime
              );
              viewer.clockViewModel.clockRange = Cesium.ClockRange.CLAMPED;
              viewer.timeline.zoomTo(
                viewer.clockViewModel.startTime,
                viewer.clockViewModel.stopTime
              );
            } else if (topic == "BCtest/manager/start") {
              payload = JSON.parse(message.payloadString);
              viewer.clockViewModel.multiplier =
                payload.taskingParameters.timeScalingFactor;
            } else if (
              topic == "BCtest/manager/time" ||
              topic == "BCtest/manager/status/time"
            ) {
              payload = JSON.parse(message.payloadString);
              viewer.clockViewModel.currentTime = Cesium.JulianDate.fromIso8601(
                payload.properties.simTime
              );
              viewer.timeline.updateFromClock();
            } else if (topic == "BCtest/manager/update") {
              payload = JSON.parse(message.payloadString);
              viewer.clockViewModel.multiplier =
                payload.taskingParameters.timeScalingFactor;
            } else if (topic == "BCtest/satellite/state") {
              payload = JSON.parse(message.payloadString);
              blueBox.orientation = new Cesium.Quaternion(
                payload.attitude[0],
                payload.attitude[1],
                payload.attitude[2],
                payload.attitude[3]
              );
              blueBox.position = new Cesium.Cartesian3(
                payload.position[0],
                payload.position[1],
                payload.position[2]
              );
            } else if (topic == "BCtest/ground/location") {
              payload = JSON.parse(message.payloadString);
              activeCheck = payload.operational;
              if (activeCheck) {
                groundColor = Cesium.Color.PINK;
                groundMaterial = Cesium.Color.PINK.withAlpha(0.1);
              } else {
                groundColor = Cesium.Color.LIGHTGRAY;
                groundMaterial = Cesium.Color.LIGHTGRAY.withAlpha(0.1);
              }
              if (!grounds[payload.groundId]) {
                <!-- Only add grounds with unique ids -->
                grounds[payload.groundId] = viewer.entities.add({
                  position: Cesium.Cartesian3.fromDegrees(
                    payload.longitude,
                    payload.latitude
                  ),
                  point: {
                    pixelSize: 8,
                    color: groundColor,
                  },
                  show: true,
                });
                <!-- Currently hardcoded cylinder dimensions, although angle read from message -->
                commsCones[payload.groundId] = viewer.entities.add({
                  position: Cesium.Cartesian3.fromDegrees(
                    payload.longitude,
                    payload.latitude,
                    100000.0
                  ),
                  cylinder: {
                    length: 200000.0,
                    topRadius:
                      200000.0 *
                      Math.tan(((90 - payload.elevAngle) * Math.PI) / 180),
                    bottomRadius: 0.0,
                    material: groundMaterial,
                    outline: true,
                    outlineWidth: 1.0,
                  },
                });
              }
            }
          } catch (err) {
            console.log("An error was caught somewhere...");
          }
        }

        client.connect({
          userName: BROKER_CLIENT_USERNAME,
          password: BROKER_CLIENT_PASSWORD,
          useSSL: true,
          onSuccess: function () {
            client.subscribe("BCtest/#", {
              onFailure: function () {
                alert("Error subscribing to topic.");
              },
              onSuccess: function () {
                client.onMessageArrived = handleMessage;
              },
            });
          },
        });
      });
    </script>
  </body>
</html>
