"""
    *This application takes all relevant simulation data published by all other applications and writes it to file

    The application contains a :obj:`Recorder` class that contains callbacks for satellite TLEs, event parameters, and
    detection and report messages that log relevant data generated by the simulation as well as the parameters used for the run.
"""


import time
from dotenv import dotenv_values
import pandas as pd
import datetime
import logging
from skyfield.api import utc

from nost_tools.simulator import Mode
from nost_tools.observer import Observer
from nost_tools.application_utils import ConnectionConfig, ShutDownObserver
from nost_tools.managed_application import ManagedApplication

from examples.utility.config import PARAMETERS
from examples.utility.schemas import EventStarted, EventDetected, EventReported

logging.basicConfig(level=logging.INFO)


class Recorder(Observer):
    """
        *The Environment object class inherits properties from the Observer object class in the NOS-T tools library*

        Attributes:
            app (:obj:`ManagedApplication`): An application containing a test-run namespace, a name and description for the app, client credentials, and simulation timing instructions 
            parameters (:obj:`Series`): Parameters from config.py
    """

    def __init__(self, app, parameters):
        self.app = app
        self.parameters = parameters
        
        # Initalize empty events dataframe 
        self.events = pd.DataFrame(
            data={
                "eventId": [i for i in range(parameters["EVENT_COUNT"])],
                "start": [None for _ in range(parameters["EVENT_COUNT"])],
                "finish": [None for _ in range(parameters["EVENT_COUNT"])],
                "detected": [[] for _ in range(parameters["EVENT_COUNT"])],
                "detected_by": [[] for _ in range(parameters["EVENT_COUNT"])],
                "reported": [[] for _ in range(parameters["EVENT_COUNT"])],
                "reported_by": [[] for _ in range(parameters["EVENT_COUNT"])],
                "reported_to": [[] for _ in range(parameters["EVENT_COUNT"])],
                "latitude": [None for _ in range(parameters["EVENT_COUNT"])],
                "longitude": [None for _ in range(parameters["EVENT_COUNT"])],
            }
        )
        self.events.set_index("eventId", inplace=True)


    def on_change():
        """
            *Standard on_change callback function format inherited from Observer object class*
        """
        pass


    def on_capella_tles(self, client, userdata, message):
        """
            *PREFIX/capella/tles* allback of standard format to log the Capella Two-Line Elements used for the simulation run to parameters :obj:`DataFrame` 

            Args:
                client (:obj:`MQTT Client`): Client that connects application to the event broker using the MQTT protocol. Includes user credentials, tls certificates, and host server-port information.
                userdata: User defined data of any type (not currently used)
                message (:obj:`message`): Contains *topic* the client subscribed to and *payload* message content as attributes 
        """
        tles=message.payload
        self.parameters["TLES"]["capella"] = tles
    

    def on_planet_tles(self, client, userdata, message):
        """
            *PREFIX/planet/tles* callback to log the Planet Two-Line Elements used for the simulation run to parameters :obj:`DataFrame` 
        
            Args:
                client (:obj:`MQTT Client`): Client that connects application to the event broker using the MQTT protocol. Includes user credentials, tls certificates, and host server-port information.
                userdata: User defined data of any type (not currently used)
                message (:obj:`message`): Contains *topic* the client subscribed to and *payload* message content as attributes 
        """
        tles=message.payload
        self.parameters["TLES"]["planet"] = tles


    def on_event_start(self, client, userdata, message):
        """
            *PREFIX/event/start* callback to log event start and finish times as well as location to events :obj:`DataFrame`
        
            Args:
                client (:obj:`MQTT Client`): Client that connects application to the event broker using the MQTT protocol. Includes user credentials, tls certificates, and host server-port information.
                userdata: User defined data of any type (not currently used)
                message (:obj:`message`): Contains *topic* the client subscribed to and *payload* message content as attributes 
        """
        start = EventStarted.parse_raw(message.payload)
        self.events["start"][start.eventId] = start.start
        self.events["finish"][start.eventId] = start.start + datetime.timedelta(hours=self.parameters['EVENT_LENGTH'])
        self.events["latitude"][start.eventId] = start.latitude
        self.events["longitude"][start.eventId] = start.longitude


    def on_detected(self, client, userdata, message):
        """
            *PREFIX/*/detected* callback to log event detection times and satellites to events :obj:`DataFrame`
        
            Args:
                client (:obj:`MQTT Client`): Client that connects application to the event broker using the MQTT protocol. Includes user credentials, tls certificates, and host server-port information.
                userdata: User defined data of any type (not currently used)
                message (:obj:`message`): Contains *topic* the client subscribed to and *payload* message content as attributes 
        """
        detect = EventDetected.parse_raw(message.payload)
        self.events["detected"][detect.eventId].append(detect.detected)
        self.events["detected_by"][detect.eventId].append(detect.detected_by)

    
    def on_reported(self, client, userdata, message):
        """
            *PREFIX/*/reported* callback to log event report times, satellites, and groundstations to events :obj:`DataFrame`
            
            Args:
                client (:obj:`MQTT Client`): Client that connects application to the event broker using the MQTT protocol. Includes user credentials, tls certificates, and host server-port information.
                userdata: User defined data of any type (not currently used)
                message (:obj:`message`): Contains *topic* the client subscribed to and *payload* message content as attributes 
        """
        report = EventReported.parse_raw(message.payload)
        self.events["reported"][report.eventId].append(report.reported)
        self.events["reported_by"][report.eventId].append(report.reported_by)
        self.events["reported_to"][report.eventId].append(report.reported_to)


# name guard used to ensure script only executes if it is run as the __main__
if __name__ == "__main__":

    # Note that these are loaded from a .env file in current working directory
    credentials = dotenv_values(".env")
    HOST, PORT = credentials["HOST"], int(credentials["PORT"])
    USERNAME, PASSWORD = credentials["USERNAME"], credentials["PASSWORD"]
    CA_LIST = credentials["CA_LIST"]
    CERTIFICATE, KEY = credentials["CERTIFICATE"], credentials["KEY"]

    # set the client credentials
    config = ConnectionConfig(USERNAME, PASSWORD, HOST, PORT, CA_LIST, CERTIFICATE, KEY, True)

    # create the managed application
    app = ManagedApplication('recorder')

    recorder = Recorder(app, PARAMETERS) 

    app.simulator.add_observer(ShutDownObserver(app))

    app.start_up(
        PARAMETERS["PREFIX"],
        config,
        True,
        time_status_step=datetime.timedelta(seconds=10) * PARAMETERS["SCALE"],
        time_status_init=datetime.datetime.fromtimestamp(PARAMETERS['SCENARIO_START']).replace(tzinfo=utc),
        time_step=datetime.timedelta(seconds=0.5) * PARAMETERS["SCALE"],
    )

    app.add_message_callback("event", "start", recorder.on_event_start)
    app.add_message_callback("capella", "tles", recorder.on_capella_tles)
    app.add_message_callback("capella", "detected", recorder.on_detected)
    app.add_message_callback("capella", "reported", recorder.on_reported)
    app.add_message_callback("planet", "tles", recorder.on_planet_tles)
    app.add_message_callback("planet", "detected", recorder.on_detected)
    app.add_message_callback("planet", "reported", recorder.on_reported)

    while not app.simulator.get_mode() == Mode.TERMINATED:
        time.sleep(1)

    time.sleep(5)
    recorder.parameters.to_json(f"outputs/{PARAMETERS['SIM_NAME']}.json", orient='index')

    # with open(f"outputs/{PARAMETERS['SIM_NAME']}.csv", "a") as f: f.write("\n\n\n")
    print(recorder.parameters["TLES"].values)
    recorder.events.to_csv(f"outputs/{PARAMETERS['SIM_NAME']}.csv", mode="w")